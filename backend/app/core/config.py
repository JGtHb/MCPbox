"""MCPbox Configuration using Pydantic Settings.

MCPbox hybrid architecture:
- Admin panel (/api/*): JWT authentication, accessed via frontend nginx proxy
- MCP Gateway (/mcp): Two modes:
  1. Local-only mode: No auth required (no service token in database)
  2. Remote mode: Cloudflare Worker proxy adds X-MCPbox-Service-Token header

The remote mode uses a Cloudflare Worker that:
- Handles OAuth via MCP Server Portal
- Proxies requests to your MCPbox tunnel
- Adds a service token header for MCPbox to verify

The service token is stored in the database (generated by the wizard) and
loaded at startup by ServiceTokenCache. No .env configuration needed.
"""

from functools import lru_cache
from typing import Any

from pydantic import PostgresDsn, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Application
    app_name: str = "MCPbox"
    app_version: str = "0.1.0"
    debug: bool = False
    log_level: str = "INFO"

    # Database
    database_url: PostgresDsn

    # Database connection pool settings
    db_pool_size: int = 20
    db_max_overflow: int = 20
    db_pool_timeout: int = 30
    db_pool_recycle: int = 1800

    # Security - encryption key for credential storage
    mcpbox_encryption_key: str

    @field_validator("mcpbox_encryption_key")
    @classmethod
    def validate_encryption_key(cls, v: str) -> str:
        """Validate encryption key is exactly 64 hex characters (32 bytes)."""
        import re

        if not v:
            raise ValueError(
                "MCPBOX_ENCRYPTION_KEY is required. Generate with: openssl rand -hex 32"
            )

        if len(v) != 64:
            raise ValueError(
                f"MCPBOX_ENCRYPTION_KEY must be exactly 64 hex characters (32 bytes), "
                f"got {len(v)} characters. Generate with: openssl rand -hex 32"
            )

        if not re.fullmatch(r"[0-9a-fA-F]+", v):
            raise ValueError(
                "MCPBOX_ENCRYPTION_KEY must contain only hexadecimal characters (0-9, a-f). "
                "Generate with: openssl rand -hex 32"
            )

        return v

    # CORS - for admin panel access
    # With same-origin nginx proxy, CORS is only needed for direct backend access
    # (e.g., local development). Default: http://localhost:3000
    cors_origins: str = "http://localhost:3000"

    # MCP CORS - separate from admin panel, for tunnel-exposed MCP gateway
    # Defaults include Claude, ChatGPT, and OpenAI origins
    mcp_cors_origins: str = "https://mcp.claude.ai,https://claude.ai,https://chatgpt.com,https://chat.openai.com,https://platform.openai.com"

    # Sandbox - requires API key for authentication
    sandbox_api_key: str = ""

    # HTTP client settings
    http_timeout: float = 30.0
    http_max_connections: int = 10
    http_keepalive_connections: int = 5

    # Rate limiting
    rate_limit_requests_per_minute: int = 100

    # JWT Authentication settings
    jwt_secret_key: str = ""
    jwt_access_token_expire_minutes: int = 15
    jwt_refresh_token_expire_days: int = 7
    jwt_algorithm: str = "HS256"

    @field_validator("jwt_secret_key")
    @classmethod
    def validate_jwt_secret_key(cls, v: str, info: Any) -> str:
        """Validate or derive JWT secret key."""
        if v and len(v) < 32:
            raise ValueError(
                f"JWT_SECRET_KEY must be at least 32 characters, got {len(v)}. "
                "Generate with: openssl rand -hex 32"
            )
        return v

    @field_validator("sandbox_api_key")
    @classmethod
    def validate_sandbox_api_key(cls, v: str) -> str:
        """Validate sandbox API key - must be set and have minimum length."""
        if not v:
            raise ValueError("SANDBOX_API_KEY is required. Generate with: openssl rand -hex 32")
        if len(v) < 32:
            raise ValueError(
                f"SANDBOX_API_KEY must be at least 32 characters, got {len(v)}. "
                "Generate with: openssl rand -hex 32"
            )
        return v

    @field_validator("rate_limit_requests_per_minute")
    @classmethod
    def validate_rate_limit(cls, v: int) -> int:
        """Validate rate limit is positive."""
        if v < 1:
            raise ValueError("rate_limit_requests_per_minute must be at least 1")
        return v

    # Cloudflare Worker deployment settings
    cf_worker_compatibility_date: str = "2025-03-01"
    cf_worker_compatibility_flags: str = "nodejs_compat"
    mcp_gateway_port: int = 8002

    # Alerting - optional webhook URL for critical alerts (Discord, Slack, etc.)
    alert_webhook_url: str = ""

    # Metrics - enable Prometheus /metrics endpoint
    enable_metrics: bool = True

    @field_validator("log_level")
    @classmethod
    def validate_log_level(cls, v: str) -> str:
        """Validate log level is a valid Python logging level."""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        upper_v = v.upper()
        if upper_v not in valid_levels:
            raise ValueError(f"log_level must be one of {valid_levels}")
        return upper_v

    @field_validator("cors_origins")
    @classmethod
    def validate_cors_origins(cls, v: str) -> str:
        """Validate CORS origins are valid URLs."""
        if not v:
            return v

        from urllib.parse import urlparse

        origins = [origin.strip() for origin in v.split(",") if origin.strip()]
        if not origins:
            raise ValueError("cors_origins must contain at least one origin")

        for origin in origins:
            parsed = urlparse(origin)
            if parsed.scheme not in ("http", "https"):
                raise ValueError(
                    f"Invalid CORS origin '{origin}': must start with http:// or https://"
                )
            if not parsed.netloc:
                raise ValueError(f"Invalid CORS origin '{origin}': must include host")
            if parsed.path and parsed.path != "/":
                raise ValueError(f"Invalid CORS origin '{origin}': should not include path")

        return v

    @property
    def cors_origins_list(self) -> list[str]:
        """Parse CORS origins from comma-separated string."""
        return [origin.strip() for origin in self.cors_origins.split(",") if origin.strip()]

    @property
    def mcp_cors_origins_list(self) -> list[str]:
        """Parse MCP CORS origins from comma-separated string."""
        return [origin.strip() for origin in self.mcp_cors_origins.split(",") if origin.strip()]

    @property
    def effective_jwt_secret_key(self) -> str:
        """Get the JWT secret key, deriving from encryption key if not set."""
        if self.jwt_secret_key:
            return self.jwt_secret_key
        # Derive from encryption key using a different suffix to ensure different key
        import hashlib

        return hashlib.sha256((self.mcpbox_encryption_key + "_jwt_secret").encode()).hexdigest()

    def check_security_configuration(self) -> list[str]:
        """Check for security configuration issues."""
        warnings = []

        if self.debug:
            warnings.append("DEBUG mode is enabled. This may expose sensitive information.")

        if self.rate_limit_requests_per_minute > 500:
            warnings.append(
                f"Rate limit is set to {self.rate_limit_requests_per_minute}/min which is high."
            )

        # SECURITY: Warn when JWT secret is derived from encryption key (SEC-011)
        if not self.jwt_secret_key:
            warnings.append(
                "JWT_SECRET_KEY not set â€” derived from MCPBOX_ENCRYPTION_KEY. "
                "Set a separate JWT_SECRET_KEY for production deployments."
            )

        # Check for duplicate secrets (security anti-pattern)
        secret_pairs = []
        if self.jwt_secret_key:
            secret_pairs.append(("JWT_SECRET_KEY", self.jwt_secret_key))
        if self.sandbox_api_key:
            secret_pairs.append(("SANDBOX_API_KEY", self.sandbox_api_key))

        seen_values: dict[str, str] = {}
        for name, value in secret_pairs:
            if value in seen_values:
                warnings.append(
                    f"{name} has the same value as {seen_values[value]}. "
                    "Each secret should be unique for defense-in-depth."
                )
            else:
                seen_values[value] = name

        return warnings


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()  # type: ignore[call-arg]


# Global settings instance
settings = get_settings()
