"""Service token cache — single source of truth from the database.

The MCP service token (shared secret between the Cloudflare Worker and MCPbox)
is generated by the wizard and stored encrypted in CloudflareConfig. This cache
loads it at startup and periodically refreshes from the database so that token
changes (e.g., wizard regeneration) are picked up by all processes (backend AND
mcp-gateway) without requiring a restart.

Call invalidate() + load() for immediate refresh (e.g., in the backend process
after the wizard regenerates the token). Other processes (mcp-gateway) will
pick up the change within TTL_SECONDS.
"""

import logging
import time

from sqlalchemy import select

from app.core.database import async_session_maker
from app.models.cloudflare_config import CloudflareConfig
from app.services.crypto import DecryptionError, decrypt_from_base64

logger = logging.getLogger(__name__)

# How often to re-check the database for token changes (seconds)
TTL_SECONDS = 30


class ServiceTokenCache:
    _instance: "ServiceTokenCache | None" = None
    _token: str | None = None
    _last_loaded: float = 0.0
    _db_error: bool = False
    _decryption_error: bool = False

    @classmethod
    def get_instance(cls) -> "ServiceTokenCache":
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    async def load(self) -> None:
        """Load service token from active CloudflareConfig."""
        try:
            async with async_session_maker() as session:
                result = await session.execute(
                    select(CloudflareConfig).where(CloudflareConfig.status == "active")
                )
                config = result.scalar_one_or_none()
        except Exception:
            # Fail-closed: if DB is unreachable, retain previous token if any,
            # otherwise set error flag so is_auth_enabled() returns True (deny-all).
            if self._token is not None:
                logger.warning("Database unreachable, retaining last known service token")
            else:
                logger.warning(
                    "Database unreachable on first load, failing closed (auth enabled, all denied)"
                )
                self._db_error = True
            # Do NOT update _last_loaded — force retry on next access
            return

        self._db_error = False

        if config and config.encrypted_service_token:
            try:
                self._token = decrypt_from_base64(config.encrypted_service_token)
                self._decryption_error = False
                logger.info("Service token loaded from database (remote auth enabled)")
            except DecryptionError:
                logger.error(
                    "Failed to decrypt service token from database — "
                    "failing closed (auth enabled, all requests denied). "
                    "Check MCPBOX_ENCRYPTION_KEY matches the key used to encrypt the token."
                )
                self._token = None
                self._decryption_error = True
        else:
            self._token = None
            self._decryption_error = False
            logger.info("No service token in database (local-only mode)")

        self._last_loaded = time.monotonic()

    async def _refresh_if_stale(self) -> None:
        """Reload from database if the cache is older than TTL_SECONDS."""
        if time.monotonic() - self._last_loaded >= TTL_SECONDS:
            await self.load()

    def invalidate(self) -> None:
        """Clear cached token so the next load() picks up the new value."""
        self._token = None
        self._decryption_error = False
        self._last_loaded = 0.0  # Force reload on next access

    @property
    def token(self) -> str | None:
        return self._token

    @property
    def auth_enabled(self) -> bool:
        return bool(self._token) or self._db_error or self._decryption_error

    async def get_token(self) -> str | None:
        """Get the cached token, refreshing from DB if stale."""
        await self._refresh_if_stale()
        return self._token

    async def is_auth_enabled(self) -> bool:
        """Check if auth is enabled, refreshing from DB if stale.

        Fail-closed: returns True if DB was unreachable or if the service
        token could not be decrypted (so all requests are denied when
        get_token() returns None).
        """
        await self._refresh_if_stale()
        return bool(self._token) or self._db_error or self._decryption_error
